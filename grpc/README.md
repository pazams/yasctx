# slog-context
[![tag](https://img.shields.io/github/tag/veqryn/slog-context.svg)](https://github.com/veqryn/slog-context/tags)
![Go Version](https://img.shields.io/badge/Go-%3E%3D%201.21-%23007d9c)
[![GoDoc](https://godoc.org/github.com/veqryn/slog-context?status.svg)](https://pkg.go.dev/github.com/veqryn/slog-context/grpc)
![Build Status](https://github.com/veqryn/slog-context/actions/workflows/build_and_test.yml/badge.svg)
[![Go report](https://goreportcard.com/badge/github.com/veqryn/slog-context/grpc)](https://goreportcard.com/report/github.com/veqryn/slog-context/grpc)
[![Coverage](https://img.shields.io/codecov/c/github/veqryn/slog-context)](https://codecov.io/gh/veqryn/slog-context)
[![Contributors](https://img.shields.io/github/contributors/veqryn/slog-context)](https://github.com/veqryn/slog-context/graphs/contributors)
[![License](https://img.shields.io/github/license/veqryn/slog-context)](../LICENSE)

Golang GRPC Interceptors for SLOG logging, that automatically logs all requests
and responses, including streaming requests and streaming responses.

### Other Great SLOG Utilities
- [slogctx](https://github.com/veqryn/slog-context): Add attributes to context and have them automatically added to all log lines. Work with a logger stored in context.
- [slogotel](https://github.com/veqryn/slog-context/tree/main/otel): Automatically extract and add [OpenTelemetry](https://opentelemetry.io/) TraceID's to all log lines.
- [sloggrpc](https://github.com/veqryn/slog-context/tree/main/grpc): Instrument [GRPC](https://grpc.io/) with automatic logging of all requests and responses.
- [slogdedup](https://github.com/veqryn/slog-dedup): Middleware that deduplicates and sorts attributes. Particularly useful for JSON logging.
- [slogbugsnag](https://github.com/veqryn/slog-bugsnag): Middleware that pipes Errors to [Bugsnag](https://www.bugsnag.com/).
- [slogjson](https://github.com/veqryn/slog-json): Formatter that uses the [JSON v2](https://github.com/golang/go/discussions/63397) [library](https://github.com/go-json-experiment/json), with optional single-line pretty-printing.

## Install
```shell
go get github.com/veqryn/slog-context/grpc
```

```go
import (
	sloggrpc "github.com/veqryn/slog-context/grpc"
)
```

## Usage
### Server Interceptors
```go
package main

import (
	"context"
	"errors"
	"io"
	"log/slog"
	"net"
	"os"
	"strings"

	slogctx "github.com/veqryn/slog-context"
	sloggrpc "github.com/veqryn/slog-context/grpc"
	pb "github.com/veqryn/slog-context/grpc/test/gen"
	"google.golang.org/grpc"
)

func init() {
	// Create the *slogctx.Handler middleware
	h := slogctx.NewHandler(slog.NewJSONHandler(os.Stdout, nil), nil)
	slog.SetDefault(slog.New(h))
}

func main() {
	ctx := context.TODO()
	slog.Info("Starting server. Please run: grpcurl localhost:8080/hello") // TODO: fix

	// Create api app
	app := &Api{}

	// Create a listener on TCP port for gRPC:
	lis, err := net.Listen("tcp", ":8000")
	if err != nil {
		slogctx.Error(ctx, "Unable to create grpc listener", slogctx.Err(err))
		panic(err)
	}

	// Create a gRPC server, and register our app as the handler/server for the service interface
	// https://github.com/grpc-ecosystem/go-grpc-middleware
	grpcServer := grpc.NewServer(
		// Add the interceptors
		// We will use the sloggrpc.AppendToAttributesAll option, which is fairly verbose with the attributes.
		// There is also a slimmer sloggrpc.AppendToAttributesDefault, which is what it used if no option is provided.
		// You can also write your own to customize which attributes are added, or rename their keys.
		// There are also other options available: WithInterceptorFilter, WithErrorToLevel, and WithLogger
		grpc.ChainUnaryInterceptor(sloggrpc.SlogUnaryServerInterceptor(sloggrpc.WithAppendToAttributes(sloggrpc.AppendToAttributesAll))),
		grpc.ChainStreamInterceptor(sloggrpc.SlogStreamServerInterceptor(sloggrpc.WithAppendToAttributes(sloggrpc.AppendToAttributesAll))),
	)
	pb.RegisterTestServer(grpcServer, app)

	// Start gRPC server
	serveErr := grpcServer.Serve(lis)
	if serveErr != nil && !errors.Is(serveErr, grpc.ErrServerStopped) {
		panic(serveErr)
	}
}

// GRPC setup
var _ pb.TestServer = &Api{}

type Api struct{}

// Each implemented RPC below includes an example of the logs generated by the sloggrpc interceptor

func (a Api) Unary(ctx context.Context, req *pb.TestReq) (*pb.TestResp, error) {
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcReq",
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "Unary",
		  "role": "server",
		  "stream_server": false,
		  "stream_client": false,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "req": {
			"name": "John",
			"option": 1
		  }
		}
	*/
	return &pb.TestResp{
		Name:   "Hello " + req.Name,
		Option: req.Option + 1,
	}, nil
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcResp",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "Unary",
		  "role": "server",
		  "stream_server": false,
		  "stream_client": false,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "ms": 0.001,
		  "resp": {
			"name": "Hello John",
			"option": 2
		  }
		}
	*/
}

func (a Api) ClientStream(stream grpc.ClientStreamingServer[pb.TestReq, pb.TestResp]) error {
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ClientStream",
		  "role": "server",
		  "stream_server": false,
		  "stream_client": true,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195
		}
	*/
	var reqNames []string
	var lastReqOption int32
	for {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamRecv",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "ClientStream",
			  "role": "server",
			  "stream_server": false,
			  "stream_client": true,
			  "peer_host": "192.168.76.213",
			  "peer_port": 49195,
			  "desc": {
				"msg_id": 3
			  },
			  "ms": 0.007708,
			  "req": {
				"name": "Bob",
				"option": 3
			  }
			}
		*/
		req, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
		reqNames = append(reqNames, req.Name)
		lastReqOption = req.Option
	}

	return stream.SendAndClose(&pb.TestResp{
		Name:   "Hello " + strings.Join(reqNames, ", "),
		Option: lastReqOption + 1,
	})
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ClientStream",
		  "role": "server",
		  "stream_server": false,
		  "stream_client": true,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "ms": 0.113458,
		  "resp": {
			"name": "Hello Bob, Bob, Bob",
			"option": 4
		  }
		}
	*/
}

func (a Api) ServerStream(req *pb.TestReq, stream grpc.ServerStreamingServer[pb.TestResp]) error {
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ServerStream",
		  "role": "server",
		  "stream_server": true,
		  "stream_client": false,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "ms": 0.032667,
		  "req": {
			"name": "Jane",
			"option": 1
		  }
		}
	*/
	for i := int32(1); i <= 3; i++ {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamSend",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "ServerStream",
			  "role": "server",
			  "stream_server": true,
			  "stream_client": false,
			  "peer_host": "192.168.76.213",
			  "peer_port": 49195,
			  "desc": {
				"msg_id": 1
			  },
			  "ms": 0.004417,
			  "resp": {
				"name": "Hello Jane",
				"option": 1
			  }
			}
		*/
		err := stream.Send(&pb.TestResp{
			Name:   "Hello " + req.Name,
			Option: req.Option + i,
		})
		if err != nil {
			panic(err)
		}
	}
	return nil
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ServerStream",
		  "role": "server",
		  "stream_server": true,
		  "stream_client": false,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "ms": 0.075041
		}
	*/
}

func (a Api) BidirectionalStream(stream grpc.BidiStreamingServer[pb.TestReq, pb.TestResp]) error {
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "BidirectionalStream",
		  "role": "server",
		  "stream_server": true,
		  "stream_client": true,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195
		}
	*/
	var i int32
	for {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamRecv",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "BidirectionalStream",
			  "role": "server",
			  "stream_server": true,
			  "stream_client": true,
			  "peer_host": "192.168.76.213",
			  "peer_port": 49195,
			  "desc": {
				"msg_id": 1
			  },
			  "ms": 0.006166,
			  "req": {
				"name": "Cat",
				"option": 1
			  }
			}
		*/
		req, err := stream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}

		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamSend",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "BidirectionalStream",
			  "role": "server",
			  "stream_server": true,
			  "stream_client": true,
			  "peer_host": "192.168.76.213",
			  "peer_port": 49195,
			  "desc": {
				"msg_id": 2
			  },
			  "ms": 0.00525,
			  "resp": {
				"name": "Hello Cat",
				"option": 2
			  }
			}
		*/
		i = req.Option + 1
		err = stream.Send(&pb.TestResp{
			Name:   "Hello " + req.Name,
			Option: i,
		})
		if err != nil {
			panic(err)
		}
	}

	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamSend",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "BidirectionalStream",
		  "role": "server",
		  "stream_server": true,
		  "stream_client": true,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "desc": {
			"msg_id": 5
		  },
		  "ms": 0.000625,
		  "resp": {
			"name": "Goodbye",
			"option": 5
		  }
		}
	*/
	return stream.Send(&pb.TestResp{
		Name:   "Goodbye",
		Option: i + 1,
	})
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "BidirectionalStream",
		  "role": "server",
		  "stream_server": true,
		  "stream_client": true,
		  "peer_host": "192.168.76.213",
		  "peer_port": 49195,
		  "ms": 0.496166
		}
	*/
}
```

### Client Interceptors
```go
package main

import (
	"context"
	"io"
	"log/slog"
	"os"

	slogctx "github.com/veqryn/slog-context"
	sloggrpc "github.com/veqryn/slog-context/grpc"
	pb "github.com/veqryn/slog-context/grpc/test/gen"
	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
)

func init() {
	// Create the *slogctx.Handler middleware
	h := slogctx.NewHandler(slog.NewJSONHandler(os.Stdout, nil), nil)
	slog.SetDefault(slog.New(h))
}

func main() {
	ctx := context.TODO()
	slog.Info("Starting client")

	// Create a grpc client connection
	conn, err := grpc.NewClient("localhost:8000",
		grpc.WithTransportCredentials(insecure.NewCredentials()),
		// Add the interceptors
		// We will use the sloggrpc.AppendToAttributesAll option, which is fairly verbose with the attributes.
		// There is also a slimmer sloggrpc.AppendToAttributesDefault, which is what it used if no option is provided.
		// You can also write your own to customize which attributes are added, or rename their keys.
		// There are also other options available: WithInterceptorFilter, WithErrorToLevel, and WithLogger
		grpc.WithChainUnaryInterceptor(sloggrpc.SlogUnaryClientInterceptor(sloggrpc.WithAppendToAttributes(sloggrpc.AppendToAttributesAll))),
		grpc.WithChainStreamInterceptor(sloggrpc.SlogStreamClientInterceptor(sloggrpc.WithAppendToAttributes(sloggrpc.AppendToAttributesAll))),
	)
	if err != nil {
		panic(err)
	}
	defer conn.Close()

	client := pb.NewTestClient(conn)

	// Each called RPC below includes an example of the logs generated by the sloggrpc interceptor

	// Test the single/unary req-resp call
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcReq",
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "Unary",
		  "role": "client",
		  "stream_server": false,
		  "stream_client": false,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "req": {
			"name": "John",
			"option": 1
		  }
		}
	*/
	resp, err := client.Unary(ctx, &pb.TestReq{
		Name:   "John",
		Option: 1,
	})
	if err != nil {
		panic(err)
	}
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcResp",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "Unary",
		  "role": "client",
		  "stream_server": false,
		  "stream_client": false,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 27.467792,
		  "resp": {
			"name": "Hello John",
			"option": 2
		  }
		}
	*/

	// Test the client streaming
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ClientStream",
		  "role": "client",
		  "stream_server": false,
		  "stream_client": true,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.0175
		}
	*/
	cStream, err := client.ClientStream(ctx)
	if err != nil {
		panic(err)
	}

	for i := int32(1); i <= 3; i++ {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamSend",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "ClientStream",
			  "role": "client",
			  "stream_server": false,
			  "stream_client": true,
			  "peer_host": "localhost",
			  "peer_port": 8000,
			  "desc": {
				"msg_id": 3
			  },
			  "ms": 0.000333,
			  "req": {
				"name": "Bob",
				"option": 3
			  }
			}
		*/
		err = cStream.Send(&pb.TestReq{
			Name:   "Bob",
			Option: i,
		})
		if err != nil {
			panic(err)
		}
	}
	resp, err = cStream.CloseAndRecv()
	if err != nil {
		panic(err)
	}
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ClientStream",
		  "role": "client",
		  "stream_server": false,
		  "stream_client": true,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.427959,
		  "resp": {
			"name": "Hello Bob, Bob, Bob",
			"option": 4
		  }
		}
	*/

	// Test the server streaming
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ServerStream",
		  "role": "client",
		  "stream_server": true,
		  "stream_client": false,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.010917,
		  "req": {
			"name": "Jane",
			"option": 1
		  }
		}
	*/
	sStream, err := client.ServerStream(ctx, &pb.TestReq{
		Name:   "Jane",
		Option: 1,
	})
	if err != nil {
		panic(err)
	}

	for {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamRecv",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "ServerStream",
			  "role": "client",
			  "stream_server": true,
			  "stream_client": false,
			  "peer_host": "localhost",
			  "peer_port": 8000,
			  "desc": {
				"msg_id": 1
			  },
			  "ms": 0.326,
			  "resp": {
				"name": "Hello Jane",
				"option": 1
			  }
			}
		*/
		resp, err = sStream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
	}
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "ServerStream",
		  "role": "client",
		  "stream_server": true,
		  "stream_client": false,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.403125
		}
	*/

	// Test bi-direction streaming
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamStart",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "BidirectionalStream",
		  "role": "client",
		  "stream_server": true,
		  "stream_client": true,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.006167
		}
	*/
	bStream, err := client.BidirectionalStream(ctx)
	if err != nil {
		panic(err)
	}

	for i := int32(1); i <= 4; i++ {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamSend",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "BidirectionalStream",
			  "role": "client",
			  "stream_server": true,
			  "stream_client": true,
			  "peer_host": "localhost",
			  "peer_port": 8000,
			  "desc": {
				"msg_id": 1
			  },
			  "ms": 0.000792,
			  "req": {
				"name": "Cat",
				"option": 1
			  }
			}
		*/
		err = bStream.Send(&pb.TestReq{
			Name:   "Cat",
			Option: i,
		})
		if err != nil {
			panic(err)
		}

		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamRecv",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "BidirectionalStream",
			  "role": "client",
			  "stream_server": true,
			  "stream_client": true,
			  "peer_host": "localhost",
			  "peer_port": 8000,
			  "desc": {
				"msg_id": 2
			  },
			  "ms": 0.299792,
			  "resp": {
				"name": "Hello Cat",
				"option": 2
			  }
			}
		*/
		resp, err = bStream.Recv()
		if err != nil {
			panic(err)
		}
		i += resp.Option - i
	}

	err = bStream.CloseSend()
	if err != nil {
		panic(err)
	}

	for {
		/*
			{
			  "time": "2025-04-03T16:42:07Z",
			  "level": "INFO",
			  "msg": "rpcStreamRecv",
			  "code_name": "OK",
			  "code": 0,
			  "grpc_system": "grpc",
			  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
			  "grpc_svc": "Test",
			  "grpc_method": "BidirectionalStream",
			  "role": "client",
			  "stream_server": true,
			  "stream_client": true,
			  "peer_host": "localhost",
			  "peer_port": 8000,
			  "desc": {
				"msg_id": 5
			  },
			  "ms": 0.182125,
			  "resp": {
				"name": "Goodbye",
				"option": 5
			  }
			}
		*/
		resp, err = bStream.Recv()
		if err == io.EOF {
			break
		}
		if err != nil {
			panic(err)
		}
	}
	/*
		{
		  "time": "2025-04-03T16:42:07Z",
		  "level": "INFO",
		  "msg": "rpcStreamEnd",
		  "code_name": "OK",
		  "code": 0,
		  "grpc_system": "grpc",
		  "grpc_pkg": "com.github.veqryn.slogcontext.grpc.test",
		  "grpc_svc": "Test",
		  "grpc_method": "BidirectionalStream",
		  "role": "client",
		  "stream_server": true,
		  "stream_client": true,
		  "peer_host": "localhost",
		  "peer_port": 8000,
		  "ms": 0.830417
		}
	*/
}
```

## Other Notes
This module is separate from the main [slogctx](github.com/veqryn/slog-context)
module in order to prevent `slogctx` from requiring GRPC and all its many
dependencies.
